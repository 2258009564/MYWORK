# BACKTRACKING

回溯三部曲如下：

- 确定参数返回值
- 确定终止条件
- 单层递归逻辑



基本框架如下 需要画出回溯的树来理解

```cpp
void backtracking(/*参数*/) // 树的有关信息，当前节点的有关信息要放在这个位置
    {
        if (/*终止条件*/) // 树到达了最深处
        {
            /*存放结果 比方说把path压入result */
            return;
        }
    	// 尝试把当前节点表示出来
        for (/*选择：本层集合中的元素(树中节点孩子的数量就是集合的大小) */)
        {
            /*
            处理节点 比方说把集合中的元素存入path
            */
            backtracking(/*路径，选择列表*/); // 递归，把树的深度推一层
            /*
            回溯，撤销处理结果 刚刚怎么压入的现在就怎么弹出
            */
        }
    }
```

## [77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/description/)



```cpp
class Solution
{
private:
    vector<vector<int>> result; // 收集不同的路径 作为leetcode函数的返回值
    vector<int> path;           // 路径 12 13 14

    void backtracking(int n, int k, int startindex) // 参数：总共的数字多少 树的最深位置 当前从树的什么位置开始
    {
        // 确认终止条件 当位置已经到达树的根部
        if (path.size() == k)
        {
            result.push_back(path);
            return;
        }
        // 把每一个节点找出来
        // 当前的节点集合就是startindex到n的所有元素
        for (int i = startindex; i <= n; i++) // 此处剪枝的核心在于 当前剩下的 >= 还需要的 也就是n-i>=k-path.size() 但是n-i并没有包含i本身 所以左边还需要加一 也就是n-(i-1)>=k-path.size() 整理就得到了题解的那种看不懂的格式
        {
            // 当前的压入路径
            path.push_back(i);
            // 递归 往树的更深一层 比较特殊的是 此时i可以直接控制接下来有多少层
            backtracking(n, k, i + 1);
            // 把压入的弹出
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combine(int n, int k)
    {
        backtracking(n, k, 1);
        return result;
    }
};
```

![image-20241107082307740](C:\Users\22580\AppData\Roaming\Typora\typora-user-images\image-20241107082307740.png)

对于backtracking函数主体 需要填入的参数至少有：

1. 这棵树的超集：回溯有的选的所有节点都应该被包含在内
2. 树的最大深度：需要一个限制来表示当前树已经到达最底层了
3. 当前节点集合：需要一个数组 或是一个数字 用以表示出当前的子节点中有多少孩子
4. 树的当前深度：形如path.size( )可以选填

围绕以上四个参数思考 基本可以成功填充出一个合理且完整的backtracking声明

```cpp
void backtracking(int n, int k, int startindex) 
```

这棵树的超集——正是 [1,n]

树的最大深度——正是k （k >= path.size( ) )

 当前节点集合——[startindex , n]

树的当前深度——可以从path.size( )中得到反映

在此 我不会对函数中的startindex参数做任何介绍 而是放在后面的递归部分详细解释 读者不妨先行思考这个参数的用意

在正式开始之前 请思考：`backtracking`是干什么用的呢？

==我将其理解为，这是一个 从当前节点开始往下分割 记录子节点信息 随后重复以上过程的 函数==

==至于if里面 不过是找到了可行结果之后将其压入`result`并进行`return` 返回到上一个节点 而已==

在接下来的函数书写中 请大家牢记这个定义 就像dp中对dp数组的定义那样 `backtracking`函数的定义直接反映了它为什么要在什么时候出现 为什么要调用那些参数

在函数书写之前 我们已经定义了两个变量

```cpp
vector<vector<int>> result; // 收集不同的路径 作为leetcode函数的返回值
vector<int> path;    // 收集任意一组可行解 用来填充result
```



接下来就是主体部分，我们可以参照isPrime函数：

```cpp
bool isPrime(int n)
{
    if (n == 1)
    {
        return 0;
    }
    if (n < 4)
    {
        return 1;
    }
    
    for (int i = 2; i <= n / i; i++)
    {
        if (n % i == 0)
        {
            return 0;
        }
    }
    return 1;
}

```

可以看出isPrime函数主要由一个if和一个for组成

上面的一个if用来特判 判断一些边界条件 用来方便快捷的返回结果

下面的for用来执行这个函数真正要做的事情——判断质数

所以我们的backtracking也可以参照这个写法,仿照`isPrime` 先把特判写出来：

什么时候需要特判呢？无非就是这棵树已经到达了最深处 也就是当前节点已经是叶子

==关于节点的信息 我们在`backtracking`的声明中已经体现出来了——这就是`backtracking`需要当前节点信息的用意之一==

到达最深处的特征信息主要有几个：

要么是当前的`sum`已经大于等于预期的`total`

要么是当前`path.size( )`已经等于预期的k

那我们应该加以判断 这个path是不是我们想要的？如果是的话 就`result.push_back(path);`

本题代码如下：

```cpp
// 确认终止条件 当位置已经到达树的根部
        if (path.size() == k)
        {
            result.push_back(path);
            return;
        }
```

这道题是找给定数量的数字 那判定“到达树根”的方式就是数字数量已经到达了预计值

这个return出现在这个地方似乎很突兀 一个void需要return做什么呢？这个问题此处暂且按下不表 我们继续梳理接下来的逻辑

回看isPrime的代码 我们在if之后才真正进入了函数的功能部分

那么我问你：这个函数的功能是什么呢？

==这是一个 从当前节点开始往下分割 记录子节点信息 随后重复以上过程的 函数==

——我可是从上面复制的原话 你看看你记清楚了没有！

也就是说 我们现在的任务如下：

1. 从当前`节点集合`中找出当前`节点`的信息并记录——可能不是那么好理解 结合这道题的例子 从1到n 就是当前的节点集合 而1 2 3 ... n 分别是一个节点 我们要做的便是从集合中找出元素
2. 从该节点开始 向下寻找可行结果——这一步要怎么实现呢？寻找可行结果的过程本身就包括了“记录节点信息” 也就是说你现在选择了{1} 那么你要判定{1,2 }是不是自己想要的 前提得是你把2记录在path内 似乎这一步本身就是backtracking函数能做的事呀

==写递归的核心在于 你要充分相信这个函数就是能干这件事的 我反复强调函数的定义就是这个用意 在你满怀信心的吧这个函数写出来之后 回头看看 那些困惑都迎刃而解了 会感到由衷的喜悦==

我们一步一步来

第一步 找出当前节点集合 遍历其中的节点并记录信息

我们发现当前节点集合就是某一个数开始 直到n

这里的“某一个数”概念不应当是模糊的 比如已经选择了1 那么某一个数就理所当然的应该从2开始

这也正是我说 backtracking里应该有当前节点信息的用意 由于父节点会对子节点施加限制，我们可以很方便的表示出接下来的节点集合

到此，startindex的伏笔就显现出来：这个参数用来很方便的记录当前节点集合的起始值

因此我们得到了节点集合[startindex , n] 遍历即可

遍历代码如下：

```cpp
for(int i = startindex; i <= n; i++)
{
	//记录信息
    
    //从下一个节点开始 重复 “记录信息 向下找” 的过程
}
```

接下来 填充两个注释部分即可

首先 记录信息 本题中有什么信息是需要被记录的呢 就是这个数字本身应当被记录进path

因此 记录信息 部分有  `path.push_back(i);`

其次 重复下一个节点开始的“记录信息 向下找” 过程





