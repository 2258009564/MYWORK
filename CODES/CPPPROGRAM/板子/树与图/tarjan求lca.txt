class DSU
{
private:
    vector<int> parent, rank, size;
    int count;

public:
    DSU(int n) : parent(n + 1), rank(n + 1, 0), size(n + 1, 1)
    {
        iota(all(parent), 0ll);
    }

    int find(int x)
    {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }

    void merge(int i, int j)
    {
        int ri = find(i), rj = find(j);
        if (ri == rj)
        {
            return;
        }

        if (rank[ri] < rank[rj])
        {
            swap(ri, rj);
        }
        parent[rj] = ri;
        size[ri] += size[rj];
        if (rank[ri] == rank[rj])
        {
            rank[ri]++;
        }
        count--;
    }

    bool issame(int i, int j)
    {
        return find(i) == find(j);
    }

    int getsize(int x)
    {
        return size[find(x)];
    }

    int getgroups()
    {
        return count;
    }

    void setfa(int a, int b)
    {
        parent[a] = b;
    }

    int getfa(int a)
    {
        return parent[a];
    }
};

void solve()
{
    int n, m, s;
    cin >> n >> m >> s;
    vector<vector<int>> adj(n + 1);
    for (int i = 2; i <= n; i++)
    {
        int u, to;
        cin >> u >> to;

        adj[u].emplace_back(to);
        adj[to].emplace_back(u);
    }

    vector<vector<int>> Q(n + 1);

    map<pair<int, int>, int> mp;
    vector<pair<int, int>> ques;
    while (m--)
    {
        int x, y;
        cin >> x >> y;
        ques.emplace_back(min(x, y), max(x, y));
        Q[x].emplace_back(y);
        Q[y].emplace_back(x);
    }

    DSU d(n);
    vector<int> vis(n + 1);
    vector<int> lca(n + 1);

    auto dfs = [&](auto &&self, int u, int fa) -> void
    {
        lca[u] = u;

        for (auto nxt : adj[u])
        {
            if (nxt == fa)
            {
                continue;
            }
            self(self, nxt, u);
            d.merge(nxt, u);
            lca[d.find(u)] = u;
        }
        for (auto nxt : Q[u])
        {
            if (!vis[nxt])
            {
                continue;
            }

            mp[make_pair(min(u, nxt), max(u, nxt))] = lca[d.find(nxt)];
        }
        vis[u] = 1;
    };
    dfs(dfs, s, 0);

    for (auto k : ques)
    {
        if (k.first == k.second)
        {
            cout << k.first << endl;
        }
        else
        {
            cout << mp[k] << endl;
        }
    }
}