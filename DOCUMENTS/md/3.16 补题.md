# I
题意：给定n 求所有和为n的排列的数量
思路：
1. 高中数学隔板法 题目等价于有n个1 需要在其中插入n - 1个板子隔开 那么可以选择的总数就是 $2^{n-1}$  实际计算的时候考虑采用位移
```cpp
void solve()
{
	int n;
	cin >> n;
	cout << (1 << (n - 1));
}
```

2. 数据量并不大，可以采用dfs，那这题就是**dfs板子题**
	我们考虑维护剩余的数字rest 每次可以从`1～rest`中选择数字 如果rest等于0 那么说明所选数字之和恰好为n 可以更新答案
```cpp
void solve()
{
	int n;
	cin >> n;
	int ans = 0;
	function<void(int)> dfs = [&](int rest) -> void
	{
		if (rest == 0)
		{
			ans++;
			return;
		}

		for (int i = 1; i <= rest; i++)
		{
			dfs(rest - i);
		}
	};
	dfs(n);
	cout << ans;
}
```

# F
题意：给定棋盘中七个位置，这些位置之间可以相互到达，现在指定两个起点，两个终点，求使得旗子从起点移动到终点的最短路径
思路：
1. bfs在搜索时具有**盲目**的性质 可以自行结合我的世界里面水源扩散的模型理解一下 这就导致bfs第一次搜索到终点时候，此时的路径**一定最短** 也就是说，bfs可以用来解决无权最短路问题。
	那么这就是一道**bfs板子**，直接写出bfs(start, end) 答案即为`min(bfs(a1, b1) + bfs(a2, b2), bfs(a1, b2) + bfs(a2, b1))`
```cpp
void solve()
{
    int a1, a2, b1, b2;
    cin >> a1 >> a2 >> b1 >> b2;
    map<int, pair<int, int>> mp = // 记录坐标方便查找 
	    {{1, {2, 0}},
        {2, {0, 2}},
        {3, {4, 2}},
        {4, {2, 4}},
        {5, {0, 6}},
        {6, {4, 6}},
        {7, {2, 8}}};
    vector v(5, vector<int>(9, 0)); // 5*9 大小的地图
    vector<pair<int, int>> d = {{2, 2}, {-2, 2}, {-2, -2}, {2, -2}}; // bfs走格子的偏移量
    
    auto bfs = [&](pair<int, int> dd, pair<int, int> en) -> int
    {
        vector vis(5, vector<int>(9, -1)); // 未访问的记为－1
        queue<pair<int, int>> q;
        q.push(dd);
        vis[dd.first][dd.second] = 0; // 起点的距离是0

        while (q.size())
        {
            auto cur = q.front();
            auto [x, y] = cur;
            q.pop();

            if (cur == en)
            {
                return vis[x][y];
            }

            for (auto &&[dx, dy] : d)
            {
                auto xx = dx + x, yy = dy + y;
                if (xx < 0 or xx >= 5 or yy < 0 or yy >= 9 or vis[xx][yy] != -1)
                {
                    continue;
                }

                vis[xx][yy] = vis[x][y] + 1; // 更新距离
                q.push({xx, yy});
            }
        }
        return 0;
    };

    auto a1b1 = bfs(mp[a1], mp[b1]);
    auto a1b2 = bfs(mp[a1], mp[b2]);
    auto a2b1 = bfs(mp[a2], mp[b1]);
    auto a2b2 = bfs(mp[a2], mp[b2]);

    int ans = min(a1b1 + a2b2, a2b1 + a1b2);
    cout << ans;
}
```
2. 打表不失为一种选择（似乎bfs不熟练的话 打起来代码时间差不多
以下代码摘自热心群友但**未经同意** 
```cpp
#include<iostream>
using namespace std;

int arr[10][10] = {{0,0,0,0,0,0,0,0},
                 {0,0,1,1,2,3,3,4},
                 {0,1,0,2,1,2,2,3},
                 {0,1,2,0,1,2,2,3},
                 {0,2,1,1,0,1,1,2},
                 {0,3,2,2,1,0,2,1},
                 {0,3,2,2,1,2,0,1},
                 {0,4,3,3,2,1,1,0}};
int main()
{
    int T;
    cin >> T;
    
    while(T--)
    {
        int a1, a2, b1, b2;
        cin >> a1 >> a2 >> b1 >> b2;
        int num1 = arr[a1][b1] + arr[a2][b2];
        int num2 = arr[a2][b1] + arr[a1][b2]; 
        
		cout << min(num1, num2) << endl;
    }
    return 0;
}
```

# H 
题意：对于一堆`(-)`构成的阵列，当`-`出现的时候直接输出其下标，当`)`出现的时候需要输出右括号下标，随后找到可以配对的最近左括号，输出左括号下标。
思路： 括号配对问题，**栈板子**。
忽略`-` ，在一次遍历中，遇到左括号就将其下标压入栈，遍历到右括号的时候就把栈顶弹出

```cpp
void solve()
{
	int n;
	cin >> n;
	stack<int> s;
	char c;
	for (int i = 1; i <= n; i++)
	{
		cin >> c;
		if (c == '-') cout << i << ' ';
		else if (c == '(') s.push(i);
		else
		{
			cout << i << ' ' << s.top() << ' ';
			s.pop();
		}
	}
}
```

# A
题意：给一堆书 求合法放置的最小宽度
思路：

---
GPT对二分答案的应用场景评价如下：
 
“二分答案”通常指在算法问题中利用二分查找来确定一个最优解或满足条件的答案。这种方法适用于以下情况：

1. **有序答案空间**  
    答案可以看作是一个有序的数值范围（或可以排序的集合），例如从 1 到某个上限的整数区间。

2. **单调性判定函数**  
    存在一个判定函数 能够判断一个候选答案 是否满足题目的要求，而且这个函数具有单调性（例如，对于某个临界值 ，所有 的情况都不满足条件，而 的情况都满足条件，或反之）。

3. **计算复杂度要求**  
    当直接枚举所有可能答案的时间复杂度过高时，二分查找可以将问题的时间复杂度从线性降低到对数级别，从而大幅提高效率。

因此，在优化问题、最小化或最大化问题中（例如求最小的满足某种条件的值），只要答案空间有序且问题能转化为一个“判定问题”，就可以考虑应用二分答案的方法。

---

在这道题中，我们显然可以从$[n + 1, n + m]$ 中找到最短宽度，而且一定有：若宽度w是合法的，那么w + 1 一定是合法的。（感性的想，如果w宽度可以放下所有的书，那么w + 1一定可以放下这些书
那么我们就可以考虑对宽度进行二分，其实就是猜一个w 如果这个w合法，那答案或许还可以更小; 如果这个w非法，那么答案一定得更大
把二分答案板子写出来之后，考虑里面的check函数 问题转化为，给定一个宽度，问这个宽度是否能放下所有需要放的书 （其实就是n + m - w)
先考虑a书，一共有n本，横着放可以放下(n / b) 本书，而高度是h - a 那么一共可以放下(n / b) * (h - a)本
再考虑b书，横着的空间为`w1 =  (w - (n / b) * b)` 可以放下 w1 / b 本书 而高度是h - b 那么一共可以放下(w1 / b) * (h - b) 本 二者相加就是能放下的最多书数目，将这个答案与需要放的书 的数目进行比较 然后判断是否合法即可
```cpp
void solve()
{
	int a, b, n, m, h;
	cin >> a >> b >> n >> m >> h;

	int l = n + 1, r = n + m, mid, ans;
	while (l <= r)
	{
		mid = l + (r - l) / 2;
		int rest = n + m - mid;
		auto check = [&]() -> bool
		{
			int w = mid;
			int ans = 0;
			ans += (n / b) * (h - a);
			w -= (n / b) * b;
			ans += (w / b) * (h - b);
			return ans >= rest;
		};
		if (check())
		{
			ans = mid; // 更新答案
			r = mid - 1; // 或许还能更小
		}
		else
		{
			l = mid + 1; // 一定更大
		}
	}
	cout << ans;
}
```
个人认为二分答案就是 两重for必定超时，但是不得不猜一个答案的无奈之举，认为某题可以暴力出结果但是害怕超时，就可以考虑二分答案。

ps: 看到了两个贪心做法，感觉思维难度相当大了，属于是天才级别。

---
以上四道题 前三道都是完全的板子，第四道要能想到二分答案，之后的贪心策略会比直接贪心容易的多，但是前提还是要会二分板子，以上四道题适合所有人补，都可以算是很经典的做法。既然到场了，认真的思考了很久题目，那就把做法学会

---













