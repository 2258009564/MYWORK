### A

### B

### C

### D
概率怎么算？

比方说有n条线段 选择每一条线段的概率分别是 `p[i]` 
那么我们4条线段 选择2和4 的总概率就是 `P = (1 - p[1]) * p[2] * (1 - p[3]) * p[4]` 
我们钦定一个初始概率 $P_{0} = \prod (1-p[i])$ 最后要求的概率是上面P 那么每一个概率就要乘上一个系数：
$$
P = P_{0} \times (p[2]\times\frac{1}{1-p[2]}) \times (p[4]\times\frac{1}{1-p[4]})
$$
又有 $p[i] = \frac{p_i}{q_{i}}$ 化简即可。

总之 记 $w_{i} = (p[i]\times\frac{1}{1-p[i]})$ ，下一步就是如何表示从1到m的覆盖了。

设 $dp[i]$ 表示 在变换后的概率空间中，通过激活某些线段，使得位置1到i-1都被恰好覆盖，且在位置i"停下"的概率
我们有 $dp[0] = 1$ 作为初始化，接下来 对于每一段 $[l, r, w]$ 组合，都应该有：
$$
dp[r] = (dp[r] + dp[l - 1] * w_{i}) % MOD
$$
其中 $dp[l - 1]$ 表示 安稳到达 `l - 1` 的概率，w表示后面这一段存在的概率，二者相乘是因为遵循分步乘法计数原理； $dp[r]$ 加上后面这一段 是因为遵循分类加法计数原理。
最后我们就求得了 $dp[m]$ 作为 从0开始 安稳到达 `m` 的概率 最后跟 $P_{0}$ 相乘 取模 即可。


```cpp
// 快速幂
int power(int base, int exp)
{
    int res = 1;
    base %= MOD;
    while (exp > 0)
    {
        if (exp & 1)
            res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp >>= 1;
    }
    return res;
}

// 模逆元
int inv(int x)
{
    return power(x, MOD - 2);
}

struct datas
{
    int l, r;
    int w; // 存储权重
};

void solve()
{
    int n, m;
    cin >> n >> m;

    int p0 = 1;

    vector<datas> v(n);
    for (int i = 0; i < n; i++)
    {
        int l, r, p, q;
        cin >> l >> r >> p >> q;
        auto curp = p * inv(q) % MOD;
        // p0 *= (1 - curp); 是错的 要特别注意取模
        p0 = (p0 % MOD * (1 + MOD - curp) % MOD) % MOD;
        v[i] = {l, r, curp * inv((1 + MOD - curp) % MOD) % MOD};
    }

    map<int, vector<pair<int, int>>> mp;

    for (auto [l, r, w] : v)
    {
        mp[l].emplace_back(r, w);
    }

    vector<int> dp(m + 1, 0);
    dp[0] = 1;

    for (int l = 1; l <= m; l++)
    {
        for (auto [r, w] : mp[l])
        {
            dp[r] = (dp[r] + dp[l - 1] * w) % MOD;
        }
    }

    cout << p0 * dp[m] % MOD;
}
```

上面出现了很多 %MOD 要是图省事可以找哥哥的[Z模板]([jiangly算法模板收集 - hh2048 - 博客园](https://www.cnblogs.com/WIDA/p/17633758.html#%E5%8F%96%E6%A8%A1%E7%B1%BBmlong--mint-%E6%96%B0%E7%89%88)) 那样会方便的多。