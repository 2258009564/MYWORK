# STL登封造极

## STL基础

### STL是什么，有什么用？

STL，英文全称 standard template library，==中文可译为标准模板库或者泛型库==，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。

STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。

> STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。

从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。

> 注意，这里提到的==容器，本质上就是封装有数据结构的模板类==，例如 list、vector、set、map 等，有关这些容器的具体用法，后续章节会做详细介绍。

### STL的优势在哪里？

在 C++ 中如果定义一个数组，可以采用如下方式：

`int a[n];`

这种定义数组的方法需要事先确定好数组的长度，即 n 必须为常量，这意味着，如果在实际应用中无法确定数组长度，则一般会将数组长度设为可能的最大值，但这极有可能导致存储空间的浪费。

所以除此之外，还可以采用在堆空间中动态申请内存的方法，此时长度可以是变量：

`int *p = new int[n];`

这种定义方式可根据变量 n 动态申请内存，不会出现存储空间浪费的问题。但是，如果程序执行过程中出现空间不足的情况时，则需要加大存储空间，此时需要进行如下操作：

1. 新申请一个较大的内存空间，即执行`int * temp = new int[m];`
2. 将原内存空间的数据全部复制到新申请的内存空间中，即执行`memecpy(temp, p, sizeof(int)*n);`
3. 将原来的堆空间释放，即执行`delete [] p; p = temp;`

而完成相同的操作，如果采用 STL 标准库，则会简单很多，因为大多数操作细节将不需要程序员关心。下面是使用向量模板类 vector 实现以上功能的示例：

```cpp
vector <int> a; //定义 a 数组，当前数组长度为 0，但和普通数组不同的是，此数组 a 可以根据存储数据的数量自动变长。
//向数组 a 中添加 10 个元素
for (int i = 0; i < 10 ; i++)
    a.push_back(i)
//还可以手动调整数组 a 的大小
a.resize(100);
a[90] = 100;
//还可以直接删除数组 a 中所有的元素，此时 a 的长度变为 0
a.clear();
//重新调整 a 的大小为 20，并存储 20 个 -1 元素。
a.resize(20, -1)
```

对比以上两种使用数组的方式不难看出，使用 STL 可以更加方便灵活地处理数据。所以，大家只需要系统地学习 STL，便可以集中精力去实现程序的功能，而无需再纠结某些细节如何用代码实现。



==一句话，所有的数据结构建立的所有用意就是对元素增查删改，而STL可以利用包装化的接口极大程度的方便这一点，让我们可以更加专注于算法的实现，而不需要去关注内存占用情况等等~~没用的东西~~...==

——所以话说回来，这些东西python的前辈们早就开发好了，到底为什么不用python呢？

### 

## STL容器

### STL容器是什么？

在实际的开发过程中，合理组织数据的存取与选择处理数据的算法同等重要，存取数据的方式往往会直接影响到对它们进行增删改查操作的复杂程度和时间消耗。事实上，当程序中存在对时耗要求很高的部分时，数据结构的选择就显得尤为重要，有时甚至直接影响程序执行的成败。

值得一提的是，之前我们一直在不断地重复实现一些诸如链表、集合等等这些常见的数据结构，这些代码使用起来往往都十分类似，只是为了适应不同数据的变化，可能需要在一些细节上做不同的处理。

那么大家有没有想过，是不是可以重复利用那些已有的实现来完成当前的任务呢？当然是可行的，有些读者已经亲自编写并实现了动态数组类、链表类、集合类等程序，并精心维护着。其实，STL中提供了专家级的几乎我们所需要的各种容器，功能更好，复用性更高。

==简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。==STL 提供有 3 类标准容器，分别是序列容器、排序容器和哈希容器，其中后两类容器有时也统称为关联容器。它们各自的含义如下表所示。

| **容器种类** | **功能**                                                     |
| ------------ | :----------------------------------------------------------- |
| 序列容器     | 主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即==容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。== |
| 排序容器     | 包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。==所以关联容器在查找时具有非常好的性能。== |
| 哈希容器     | c++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，==哈希容器中的元素是未排序的，元素的位置由哈希函数确定。== |

> 注意，由于哈希容器直到 C++ 11 才被正式纳入 C++ 标准程序库，而在此之前，“民间”流传着 hash_set、hash_multiset、hash_map、hash_multimap 版本，不过该版本只能在某些支持 C++ 11 的编译器下使用（如 VS），有些编译器（如 gcc/g++）是不支持的。

以上 3 类容器的存储方式完全不同，因此使用不同容器完成相同操作的效率也大不相同。所以在实际使用时，要善于根据想实现的功能，选择合适的容器。

### 简单介绍

好的，我们详细介绍每个 STL 容器的增、查、删、改的所有方式，并补充 `string` 的相关内容。

#### 1. **向量（vector）**

**概念**：动态数组，允许随机访问。

- **增加**：
  - `push_back(value)`：在末尾添加元素。
  - `insert(position, value)`：在指定位置插入元素。
  
- **查找**：
  - `vec[index]`：使用下标访问元素。
  - `at(index)`：安全访问元素，越界时抛出异常。

- **删除**：
  - `pop_back()`：删除末尾元素。
  - `erase(position)`：删除指定位置的元素。
  - `clear()`：删除所有元素。

- **修改**：
  - `vec[index] = newValue`：修改指定下标的元素。
  - `at(index) = newValue`：使用 `at` 方法修改元素。

#### 2. **链表（list）**

**概念**：双向链表，支持高效的插入和删除。

- **增加**：
  - `push_back(value)`：在末尾添加元素。
  - `insert(position, value)`：在指定位置插入元素。
  
- **查找**：
  - 遍历元素，使用迭代器（如 `begin()` 和 `end()`）进行查找。

- **删除**：
  - `pop_back()`：删除末尾元素。
  - `pop_front()`：删除开头元素。
  - `erase(position)`：删除指定位置的元素。
  - `clear()`：删除所有元素。

- **修改**：
  - 使用迭代器修改元素，例如 `*it = newValue`。

#### 3. **集合（set）**

**概念**：存储唯一元素，自动排序。

- **增加**：
  - `insert(value)`：添加元素。

- **查找**：
  - `find(value)`：查找元素，返回迭代器。
  - `count(value)`：检查元素是否存在（返回 0 或 1）。

- **删除**：
  - `erase(value)`：删除指定元素。
  - `clear()`：删除所有元素。

- **修改**：
  - 不支持直接修改，需删除再插入。

#### 4. **映射（map）**

**概念**：键值对存储，键唯一。

- **增加**：
  - `insert({key, value})`：插入键值对。
  - `map[key] = value`：添加或修改元素。

- **查找**：
  - `find(key)`：查找键，返回迭代器。
  - `count(key)`：检查键是否存在（返回 0 或 1）。
  - `map[key]`：获取对应值。

- **删除**：
  - `erase(key)`：删除指定键的元素。
  - `clear()`：删除所有元素。

- **修改**：
  - `map[key] = newValue`：修改键对应的值。

#### 5. **栈（stack）**

**概念**：后进先出（LIFO）。

- **增加**：
  - `push(value)`：在顶部添加元素。

- **查找**：
  - `top()`：查看顶部元素。

- **删除**：
  - `pop()`：删除顶部元素。

- **修改**：
  - 不能直接修改，需先 `pop` 然后 `push`。

#### 6. **队列（queue）**

**概念**：先进先出（FIFO）。

- **增加**：
  - `push(value)`：在尾部添加元素。

- **查找**：
  - `front()`：查看前面的元素。

- **删除**：
  - `pop()`：删除前面的元素。

- **修改**：
  - 不能直接修改，需先 `pop` 然后 `push`。

#### 7. **字符串（string）**

**概念**：字符数组的动态封装，支持文本操作。

- **增加**：
  - `push_back(char)`：在末尾添加字符。
  - `insert(index, substring)`：在指定位置插入子串。

- **查找**：
  - `s[index]`：使用下标访问字符。
  - `at(index)`：安全访问字符。
  - `find(substring)`：查找子串的位置。

- **删除**：
  - `pop_back()`：删除末尾字符。
  - `erase(index, count)`：从指定位置删除字符。
  - `clear()`：清空字符串。

- **修改**：
  - `s[index] = newChar`：修改指定位置的字符。
  - `replace(index, count, substring)`：替换指定位置的字符。

#### 总结

以上就是 STL 中各个容器的增、查、删、改的所有方式，以及 `string` 的基本操作。希望这能帮助你更好地理解 STL 容器！如果还有其他问题，欢迎继续提问！

### STL序列式容器

所谓序列容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。

需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：

- ##### array<T,N>（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，==其长度就是固定不变的==，这意味着不能增加或删除元素，只能改变某个元素的值；

- ##### vector<T>（向量容器）：用来存放 T 类型的元素，==是一个长度可变的序列容器==，即在存储空间不足时，会自动申请更多的内存。使用此容器，在==尾部==增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；

- ##### deque<T>（双端队列容器）：和 vector 非常相似，区别在于使用该容器==不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效==，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；

- ##### list<T>（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，==在这个序列的任何地方都可以高效地增加或删除元素==（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。

- ##### forward_list<T>（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，==它内部的元素只能从第一个元素开始访问==，是一类比链表容器快、更节省内存的容器。

> 注意，其实除此之外，stack<T> 和 queue<T> 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器，有关它们的介绍，会放到后续章节中。

#### array

#### vector(向量容器)

##### 简介

vector 容器是 STL中最常用的容器之一，它和 array 容器非常类似，都可以看做是对普通数组的“升级版”。不同之处在于，==array 实现的是静态数组（容量固定的数组）==，而 ==vector 实现的是一个动态数组，即可以进行元素的插入和删除==，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。

vector 常被称为向量容器，因为==该容器擅长在尾部插入或删除元素，在常量时间内就可以完成==，时间复杂度为`O(1)`；而对于在容器头部或者中部插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶`O(n)`。

vector 容器以类模板 vector<T>（ T 表示存储元素的类型）的形式定义在 <vector> 头文件中，并位于 std 命名空间中。因此，在创建该容器之前，代码中需包含如下内容：

```cpp
#include <vector>
using namespace std;
```

> 注意，std 命名空间也可以在使用 vector 容器时额外注明，两种方式都可以。

##### 创建容器

1. 直接使用 ==数据结构类型<数据类型> 结构名字==来创建

   例如：

   ```cpp
   std::vector<double> values;
   ```

   注意，这是一个空的 vector 容器，因为容器中没有元素，所以没有为其分配空间。当添加第一个元素（比如使用 push_back() 函数）时，vector 会自动分配内存。

2. 和其他容器一样，可以在创建的同时指定初始值以及元素个数，比如：

   ```cpp
   std::vector<int> primes {2, 3, 5, 7, 11, 13, 17, 19};
   ```

   这样就创建了一个含有 8 个素数的 vector 容器。

3. 在创建 vector 容器时，也可以仅指定元素个数：

   ```cpp
   std::vector<double> values(20,1.0);
   ```

   > 注意，圆括号 () 和大括号 {} 是有区别的，前者（例如 (20) ）表示元素的个数，而后者（例如 {20} ） 则表示 vector 容器中只有一个元素 20。

   第二个参数指定了所有元素的初始值，因此这 20 个元素的值都是 1.0。

   第二个形参的初始值为0，因此直接不填就可以把值初始化为0，达到数组初始化的效果。

##### 增

要知道，向 vector 容器中添加元素的唯一方式就是使用它的成员函数，如果不调用成员函数，非成员函数既不能添加也不能删除元素。这意味着，vector 容器对象必须通过它所允许的函数去访问，迭代器显然不行。

###### push_back() 尾部添加

该成员函数的功能是在 vector 容器尾部添加一个元素，用法也非常简单，比如：

```cpp
#include <iostream>
#include <vector>
using namespace std;//以后这些头文件，命名空间和主函数之类的东西就省略啦，用来给大家更加清晰的展现代码逻辑。
int main()
{
    vector<int> values{};
    values.push_back(1);//从末尾增加一个元素1
    values.push_back(2);//从末尾增加一个元素2
    for (int i = 0; i < values.size(); i++) {
        cout << values[i] << " ";//输出元素
    }
    return 0;
}
```

输出后的结果如下所示：

```
1 2
```

这个非常直观 没啥好讲的

###### emplace_back() 尾部添加

该函数是 C++ 11 新增加的，其功能和 push_back() 相同，都是在 vector 容器的尾部添加一个元素。

其用法也很简单，这里直接举个例子：

```cpp
vector<int> values{};
values.emplace_back(1);
values.emplace_back(2);
for (int i = 0; i < values.size(); i++)
{
	cout << values[i] << " ";
}
```

运行结果为：

```
`1 2`
```

以上 2 段代码，只是用 emplace_back() 替换了 push_back()，既然它们实现的功能是一样的，那么 C++ 11 标准中为什么要多此一举呢？

###### emplace_back()和push_back()的区别

emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。

==一句话，完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议大家优先选用 emplace_back()。==

###### insert() 中间插入

insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素，用法说明如下：

| 语法格式                        | 用法说明                                                     |
| ------------------------------- | ------------------------------------------------------------ |
| iterator insert(pos,elem)       | 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 |
| iterator insert(pos,n,elem)     | 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 |
| iterator insert(pos,first,last) | 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 |
| iterator insert(pos,initlist)   | 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 |

例如：

```cpp
std::vector<int> demo{1,2};
//第一种格式用法
demo.insert(demo.begin() + 1, 3);//{1,3,2}

//第二种格式用法
demo.insert(demo.end(), 2, 5);//{1,3,2,5,5}

//第三种格式用法
std::array<int,3>test{ 7,8,9 };
demo.insert(demo.end(), test.begin(), test.end());//{1,3,2,5,5,7,8,9}

//第四种格式用法
demo.insert(demo.end(), { 10,11 });//{1,3,2,5,5,7,8,9,10,11}

for (int i = 0; i < demo.size(); i++) {
    cout << demo[i] << " ";
}
```

输出结果为：

```cpp
1 3 2 5 5 7 8 9 10 11
```



###### emplace() 中间插入

emplace() 是 C++11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。

> 再次强调，emplace() 每次只能插入一个元素，而不是多个。

该函数的语法格式如下：

```cpp
iterator.emplace (const_iterator pos, args...);//iterator是vector的名字噢
```

其中，pos 为指定插入位置的迭代器；args... 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。

> 简单的理解 args...，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传入相应数量的参数。

举个例子：

```cpp
std::vector<int> demo1{1,2};
//emplace() 每次只能插入一个 int 类型元素
demo1.emplace(demo1.begin(), 3);
for (int i = 0; i < demo1.size(); i++) {
cout << demo1[i] << " ";
}
```

运行结果为：

```cpp
3 1 2
```

###### insert()和emplace()的区别

既然 emplace() 和 insert() 都能完成向 vector 容器中插入新元素，那么谁的运行效率更高呢？答案是 emplace()。

原因是：通过 insert() 函数向 vector 容器中插入 testDemo 类对象，需要调用类的构造函数和移动构造函数（或拷贝构造函数）；而通过 emplace() 函数实现同样的功能，只需要调用构造函数即可。

==一句话，emplace() 在插入元素时，是在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。因此，在实际使用中，推荐大家优先使用 emplace()。==

### 特殊的string



## STL迭代器

当然可以！让我们深入探讨迭代器的概念，包括它们的类型、用法、细节和一些高级用法。

### 1. 迭代器的定义

迭代器是一种抽象数据类型，用于遍历容器（如 `vector`、`list`、`set` 等）中的元素。它们提供了一种统一的方法来访问容器中的数据，而不需要关心容器的底层实现。

### 2. 迭代器的类型

C++ 标准库中的迭代器主要分为以下几类：

#### 2.1 输入迭代器（Input Iterator）

- **特性**：只能读取数据。
- **使用场景**：适用于一次性读取数据的情况。
- **示例**：
  ```cpp
  istream_iterator<int> it(cin); // 从标准输入读取整数
  ```

#### 2.2 输出迭代器（Output Iterator）

- **特性**：只能写入数据。
- **使用场景**：适用于将数据写入容器的场景。
- **示例**：
  ```cpp
  ostream_iterator<int> out_it(cout, " "); // 将整数输出到标准输出
  ```

#### 2.3 前向迭代器（Forward Iterator）

- **特性**：可以读取和写入数据，且支持多次遍历。
- **使用场景**：适用于需要多次遍历的容器。
- **示例**：`std::list` 和 `std::forward_list` 的迭代器。

#### 2.4 双向迭代器（Bidirectional Iterator）

- **特性**：可以在两个方向上遍历（前进和后退）。
- **使用场景**：适用于支持双向遍历的容器。
- **示例**：`std::list` 和 `std::set` 的迭代器。

#### 2.5 随机访问迭代器（Random Access Iterator）

- **特性**：可以任意访问容器中的元素，支持加法、减法等操作。
- **使用场景**：适用于随机访问的情况，如 `std::vector` 和 `std::deque`。
- **示例**：
  ```cpp
  vector<int> vec = {1, 2, 3, 4};
  auto it = vec.begin() + 2; // 随机访问第三个元素
  ```

### 3. 迭代器的基本操作

#### 3.1 创建迭代器

通过容器的成员函数 `begin()` 和 `end()` 获取迭代器：

```cpp
vector<int> vec = {1, 2, 3};
auto it = vec.begin(); // 指向第一个元素
auto end_it = vec.end(); // 指向最后一个元素的下一个位置
```

#### 3.2 访问元素

使用解引用操作符 `*` 访问迭代器指向的元素：

```cpp
cout << *it; // 输出 1
```

#### 3.3 移动迭代器

使用 `++` 和 `--` 操作符移动迭代器：

```cpp
++it; // 移动到下一个元素
--it; // 移动到前一个元素
```

对于随机访问迭代器，可以使用加法和减法：

```cpp
it += 2; // 向前移动两个位置
it -= 1; // 向后移动一个位置
```

#### 3.4 比较迭代器

可以使用 `==` 和 `!=` 比较迭代器是否指向同一位置：

```cpp
if (it != end_it) {
    cout << "Not at the end!";
}
```

### 4. 使用迭代器的示例

以下是一个更复杂的示例，展示了如何使用迭代器进行各种操作：

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for std::sort
using namespace std;

int main() {
    vector<int> vec = {5, 3, 4, 1, 2};

    // 使用迭代器排序
    sort(vec.begin(), vec.end());

    // 使用迭代器遍历并输出
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        cout << *it << " "; // 输出已排序的元素
    }
    cout << endl;

    // 修改容器中的元素
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        *it *= 2; // 将每个元素乘以 2
    }

    // 再次输出修改后的元素
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        cout << *it << " "; // 输出 2 4 6 10
    }
    cout << endl;

    return 0;
}
```

### 5. 迭代器与算法

C++ STL 提供了许多算法（如 `std::sort`、`std::find` 等），它们通常接受迭代器作为参数。这使得算法可以与任何支持迭代器的容器一起使用。

```cpp
#include <algorithm> // for std::find

int main() {
    vector<int> vec = {1, 2, 3, 4, 5};

    auto it = find(vec.begin(), vec.end(), 3); // 查找元素 3
    if (it != vec.end()) {
        cout << "Found: " << *it << endl; // 输出 "Found: 3"
    }

    return 0;
}
```

### 6. 迭代器的注意事项

- **合法性**：确保迭代器在有效范围内，避免访问越界。
- **不变性**：在使用迭代器遍历容器时，通常不应对容器进行结构性修改（例如，添加或删除元素），否则会使迭代器失效。

### 7. 迭代器的适配器

C++ STL 还提供了一些迭代器适配器，可以用来转换和处理迭代器：

- **反向迭代器（`std::reverse_iterator`）**：允许反向遍历容器。
- **插入迭代器（如 `std::inserter`）**：将元素插入到容器的特定位置。

### 反向迭代器示例

```cpp
#include <iostream>
#include <vector>
#include <iterator> // for std::reverse_iterator
using namespace std;

int main() {
    vector<int> vec = {1, 2, 3, 4, 5};

    // 使用反向迭代器遍历
    for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
        cout << *it << " "; // 输出 5 4 3 2 1
    }
    cout << endl;

    return 0;
}
```

### 总结

迭代器是 C++ STL 中非常强大的工具，它们提供了一种一致的方式来访问和操作不同类型的容器。通过掌握迭代器，你可以更有效地利用 STL 提供的强大功能。

如果你有特定的方面需要进一步了解或更多的示例，请告诉我！

## 写在最后的一些小知识

### 什么是函数？什么是方法？

**函数** 是一段独立的代码，可以在没有对象的情况下被调用。它只关心自己接收的输入和产生的输出。

**方法** 是和对象绑定的函数。它定义在类中，用于操作类的实例数据。方法的调用总是需要一个对象，而这个对象会影响方法的行为。

**简单对比**：

- 函数：在类外定义，不依赖对象。
- 方法：在类内定义，操作对象的数据。

看不懂吗？看不懂就请看下文。

### 什么是类？什么是结构体？

**类** 是面向对象编程中的核心概念。它不仅定义了数据结构，还包含了操作这些数据的函数（方法）。类提供了更高的封装性和抽象层次，使得代码更模块化、可重用。

**结构体** 是一种简单的数据聚合方式，通常只包含数据字段，没有复杂的行为（即没有方法）。在许多编程语言中，结构体是类的简化版，主要用于存储数据。

#### 类

**类**（Class）是面向对象编程的核心，它不仅包含数据，还封装了操作这些数据的函数（方法）。类提供了更高的封装性、继承和多态等特性，使代码更模块化和可复用。

举一个并不恰当的例子，如果不使用类，写”一个人去银行取钱“可能要进行繁琐的操作，需要多个变量不断代换。

而使用类来完成这个操作，可以一次性把存款，取款，转存乃至去银行丢垃圾（？）全部写完 最后调用的时候只需要简单的几步，

对于使用者来说，庞大的函数结构都被埋藏在深处，浮在表面的只是几个函数（方法）名称，只需要简单的==创建实例==就好了

用python来形象化的描述这俩东西，如下：

```python
class Bank:
 def __init__(self, name, balance):# 初始化
        self.name = name
        self.balance = balance

    def deposit(self, amount):# 存款
        self.balance += amount
        print(f"{amount}元已存入，当前余额为{self.balance}元")

    def withdraw(self, amount):# 取款
        if amount > self.balance:
            print("余额不足，无法取款")
        else:
            self.balance -= amount
            print(f"{amount}元已取出，当前余额为{self.balance}元")

    def transfer(self, amount, other_bank):# 转账
        if amount > self.balance:
            print("余额不足，无法转账")
        else:
            self.balance -= amount
            other_bank.balance += amount
            print(f"{amount}元已转出，当前余额为{self.balance}元")
            
# 创建两个银行对象
bank1 = Bank("银行1", 1000)
bank2 = Bank("银行2", 2000)
# 存款
bank1.deposit(500)
# 取款
bank1.withdraw(200)
# 转账
bank1.transfer(300, bank2)
# 查询余额
print(f"银行1余额：{bank1.balance}元")
print(f"银行2余额：{bank2.balance}元")
```

1~23行就是写了一个类 可以结合注释大概看一下思路。

而25行开始 就是给使用者用的 可以看到使用者只需要创建一个对象 然后调用函数就显得轻而易举理所应当

![image-20240917200401022](C:\Users\22580\AppData\Roaming\Typora\typora-user-images\image-20240917200401022.png)

输出结果如下，对比一下代码就可以发现——即使没有学过python也可以看得很清楚。

在上述示例中：

- **`Bank`** 类封装了银行账户的属性（`name` 和 `balance`）和操作（`deposit`、`withdraw`、`transfer`）。
- 使用类时，我们只需要创建对象并调用方法，隐藏了内部复杂的实现细节。

通过同时封装数据和函数方法，简洁而高效的达到了使用目的，大幅度提高使用效率，这就是类的优越之处。

我们正在学的STL，其实也就是一个又一个的类呀，创建实例的过程就是26和27，而增查删改其实就是作用于类对象的各种方法。前人已经为我们创造了这么繁杂这么庞大的类模板，让我们一起感谢（阿门

#### 结构体

**结构体**（Struct）是一种简单的数据聚合方式，通常只包含数据字段而没有复杂的行为（即没有方法）。结构体一般用于存储数据而不是封装行为。

```python
from collections import namedtuple #python中并没有结构体这么一说 所以我使用元组加以代替

# 定义一个命名元组

Bank = namedtuple('Bank', ['name', 'balance'])

# 创建一个实例

bank1 = Bank(name='银行1', balance=1000)

# 访问属性

print(f"银行名称：{bank1.name}")
print(f"银行余额：{bank1.balance}")
```

对比之下可以看出，其实结构体就是比类少了个方法。

CHATGPT的解释如下：

==结构体在编程中主要用于组织和管理数据，提供了数据封装、增强代码可读性、内存管理、简化函数接口、支持复杂数据结构等功能。尽管现代编程语言中的类和对象提供了更多功能，但结构体仍然是一个重要的概念，特别是在需要高效和简洁数据管理的场景中。==

`std::vector<int>::iterator` 是一个类型，表示指向 `std::vector<int>` 中元素的迭代器。

### 迭代器详细解释：

1. **`std::vector<int>`**：这是一个存储 `int` 类型元素的动态数组（向量）。`std::vector` 是 C++ 标准库中的一个模板类。
2. **`::iterator`**：`iterator` 是 `std::vector` 类中的一个类型定义，表示一个迭代器，可以用来遍历 `vector` 中的元素。

#### 创建和使用迭代器的步骤：

1. **声明迭代器**：

   ```cpp
   std::vector<int>::iterator it;
   ```

   这里 `it` 是一个指向 `int` 的迭代器。

2. **初始化迭代器**：

   ```cpp
   it = vec1.begin();
   ```

   将 `it` 设置为指向 `vec1` 的第一个元素。

3. **访问元素**：

   ```cpp
   int firstElement = *it; // 解引用迭代器，获取第一个元素的值
   ```

#### 示例代码：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec1 = {10, 20, 30, 40, 50};

    // 创建迭代器
    std::vector<int>::iterator it = vec1.begin();

    // 使用迭代器访问元素
    std::cout << "First element: " << *it << std::endl; // 输出: 10

    return 0;
}
```

在这个例子中，`it` 是一个迭代器，它指向 `vec1` 中的第一个元素，解引用 `*it` 可以得到这个元素的值。

