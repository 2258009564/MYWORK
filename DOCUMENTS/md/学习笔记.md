# 20250112 异或

## 异或的性质

1. **实质是二进制无进位加法 例如 1011 + 1101 = 0110**

2. **异或运算满足交换律、结合律，也就是同一批数字，不管异或顺序是什么，最终的结果都是一个**

3. **n ^ 0 = n, n ^ n = 0  可以结合第一个加法来理解**

4. **整体异或和如果是x,整体中某个部分的异或和如果是y,那么剩下部分的异或和是 x ^ y 可以结合2的结合律，交换律来理解**

   

这些结论最重要的就是1结论，所有其他结论都可以由这个结论推论得到
其中第4相关的题目最多，利用区间上异或和的性质

***区间异或和的性质***
计算从 0 到 x 的异或和：

- 通过观察，可以发现异或的规律每四个数重复一次：
- 如果 `x % 4 == 0`，则 `xor(0, x) = x`
- 如果 `x % 4 == 1`，则 `xor(0, x) = 1`
- 如果 `x % 4 == 2`，则 `xor(0, x) = x + 1`
- 如果` x % 4 == 3`，则 `xor(0, x) = 0`

计算区间 [l, r] 的异或和：
假设我们可以计算出 `xor(0, r) ` 和`  xor(0, l-1)` ，那么： ```xor(l, r)``` =` xor(0, r)` ^ `xor(0, l-1)`


## 异或的骚操作

1. **交换两个数**

```cpp
int a = 1, b = 2;
a = a ^ b;
b = a ^ b;
a = a ^ b;
// as a result a equals 2 and b equals 1
```

   具体过程：

- **第一步**：`a = a ^ b;` 之后，`a` 保存的是 `a` 和 `b` 异或的结果，即 `a` 和 `b` 的混合信息。
- **第二步**：`b = a ^ b;` 在这一步中，`a` 已经存储了 `a ^ b`，所以 `b = (a ^ b) ^ b`。根据自反性，`b` 变成了原来的 `a`。
- **第三步**：`a = a ^ b;` 最后，`a = (a ^ b) ^ a`，根据自反性，`a` 变成了原来的 `b`。

所以，通过这三步异或操作，我们完成了 `a` 和 `b` 的交换，而无需使用额外的临时变量。这种方法是非常高效且空间优化的，尤其是在内存受限的情况下。

2. **找到缺失的数字**

```cpp
// 在1~10中随便挖掉一个 让快速找出

// 原理： 缺失的数字 = 所有数异或和 - 剩下数字的异或和

vector<int> v = {1, 2, 3, 4, 6, 7, 8, 9};

// 计算1 ~ 10 的异或和 也就是 xor(0, 10) ^ xor(0, 0) 而xor(0, 0) = 0

int xor_1_to_10 = 10 + 1 = 11;

// 计算v中数字的异或和 应当从0开始

int xor_v = 0;
for (int i = 0; i < v.size(); i++) xor_v ^= v[i];

// 计算剩下的数字

int result = xor_1_to_10 ^ xor_v;

```

例：

**leetcode268**

可以说是异或很好的板子题

ac codes are as follows:

```cpp
class Solution
{
public:
    int xor_(int x)
    {
        if (x % 4 == 0)
        {
            return x;
        }
        if (x % 4 == 1)
        {
            return 1;
        }
        if (x % 4 == 2)
        {
            return x + 1;
        }
        return 0;
    }

    int missingNumber(vector<int> &nums)
    {
        int n = nums.size();

        // calculate xor from 0 to n

        int xor_1_to_n = xor_(n);

        // calculate xor from array
        int temp = 0;
        for (auto &&i : nums)
        {
            temp ^= i;
        }

        return xor_1_to_n ^ temp;
    }
};
```



3. **数组中1种数出现了奇数次，其他的数都出现了偶数次，返回出现了奇数次的数**

   用到的是性质2 可以往上看一眼

   ```cpp
   vector<int> v = {1, 1, 1, 1, 2, 2, 3};
   int res = 0;
   for (auto && i : v) res ^= i;
   return res; 
   // as a result res equals 3
   ```


例：

**leetcode136**

ac codes are as follows:

```c++
class Solution
{
public:
    int singleNumber(vector<int> &nums)
    {
        int ans = 0;
        for (auto &&i : nums)
        {
            ans ^= i;
        }
        return ans;
    }
};
```



4. Brian Kernighan算法-提取出二进制状态中最右侧的1

其实就是lowbit 将在树状数组中反复使用

对一个正数x取反 得到x ^ 0

对其结果 + 1 得到 ~x + 1 其实就是相反数-x

最后做与运算 则有

```c++
int lowbit(x)
{
    return x & (-x);
}
```

最后得到的结果在二进制下将至多只有一个1



5. 数组中有2种数出现了奇数次，其他的数都出现了偶数次，返回这2种出现了奇数次的数

原理：设结果a, b 使得 `a != b` 那么一定有 a 和 b 在二进制的某一位不相同
那么原数组中一定可以分成两种数字： 第一种在那一位是0 第二种在那一位是1
我们只需要分别对这两种数字进行异或和 就能筛选出唯一的数字
***思考：二进制下有多少位不相同 有影响吗？***
**ans：**没有影响 我们要做的只是筛选工作 选出来即可



code：

```c++
vector<int> v = {1, 1, 2, 3, 3, 4};

int temp = 0;
for (auto &&i : v) temp ^= i;
int lowbit_num = temp & (-temp);

// 得到了这个唯一的"1" 我们如何继续操作？
// 我们继续用到与运算：如果num 在 lowbit_num的对应位数上是1 那么结果就是num 如果是0 那么结果就是00000000 也就是0

int ans1 = 0;
for (auto &&i : v) if (i & lowbit_num) ans1 ^= i;
ans2 = ans1 ^ lowbit_num;
// 用到了性质4 部分和 = 全体和 ^ 另一部分和
```

例:

leetcode260

ac codes are as follows:

```c++
class Solution
{
public:
    vector<int> singleNumber(vector<int> &nums)
    {
        unsigned xor_nums = 0;
        for (auto &&i : nums)
        {
            xor_nums ^= i;
        }

        int lowbit = xor_nums & (-xor_nums);

        int res1 = 0;
        for (auto &&i : nums)
        {
            if (lowbit & i)
            {
                res1 ^= i;
            }
        }
        return {res1, res1 ^ (int)xor_nums};
    }
};

```





> [!IMPORTANT]
>
> 为什么使用 `unsigned` 类型来避免溢出
>
> 1. **补码表示和溢出问题：**
>    - 在 C++ 中，整数是以补码的形式存储的。
>    - 对于 `int` 类型，取负数的操作涉及到补码的反转，当 `xor_nums` 等于 `INT_MIN`（即 `-2147483648`）时，`-INT_MIN` 会导致溢出。因为 `INT_MIN` 是 `-2147483648`，其补码表示超出了 `int` 类型的范围，因此无法表示其取反的结果，导致未定义的行为。
> 2. **使用 `unsigned` 类型：**
>    - `unsigned` 类型在存储负数时表现不同，因为它不使用补码。无符号整数的范围是 `[0, 2^n - 1]`，它不涉及负数，因此在进行负数取反时不会出现溢出问题。
>    - 当你将 `xor_nums` 声明为 `unsigned` 类型时，它将不会出现负数，因此 `-xor_nums` 会按照无符号整数的规则进行计算，不会发生溢出。

**我们可以在以下场景尝试使用unsigned：**

**位运算中出现了负数**

如果你需要执行位操作时，运算符会作用于负数，例如 `a & b`、`a ^ b` 或 `a | b`，而某些操作可能涉及到负数的补码表示。这时，使用 `unsigned` 类型可以避免这些负数影响结果，因为无符号整数的操作不会引发负数的补码计算。

**进行最低位 1 查找（`x & (-x)`）时**

在诸如 `x & (-x)` 的操作中，目标是找到二进制表示中最低的 `1`。如果 `x` 是负数（例如 `-2147483648`），在 `int` 类型中执行 `-x` 可能导致溢出，因为补码表示不能正确处理 `INT_MIN`。而如果使用 `unsigned` 类型， `x` 会被视为无符号数，取负时不会引发溢出问题。




6. 数组中只有1种数出现次数少于m次，其他数都出现了m次，返回出现次数小于m次的那种数

to be continued......



> **今天的题目基本上都可以用map去重做， 这里是为了更好的熟悉异或运算**





