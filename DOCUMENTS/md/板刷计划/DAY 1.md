# [2060E](https://codeforces.com/problemset/problem/2060/E)

> 题意：
> 给两个无向图`F` 和 `G` 顶点相同但是边不同 想要使得 `F`长得跟`G`一模一样 问操作次数

这个问题要求你通过一系列操作（添加或删除边），将图 `F` 变换成与图 `G` 相同的连通性。问题本质上是关于图的 **连通性**，需要比较图 `F` 和图 `G` 的连通性结构，并且通过最小的操作使两者的连通性结构相同。

> 思路：
> 这里要使用并查集的很优越的性质。
> 我们知道 并查集在合并过程中会**逐渐将顶点合并 降低集合的数量** 所以利用并查集来处理两个图是极为高效的选择 。

### 使用并查集的原因：

1. **图的连通性判断**：并查集特别适用于处理图的连通性问题。对于每个图中的顶点，我们可以使用并查集来维护它们的连通性，即判断两个顶点是否在同一个连通块中。
    
2. **合并操作和查找操作**：并查集的基本操作是 `find` 和 `union`，其中 `find` 用于查找一个节点所在的连通块，`union` 用于将两个连通块合并。在本问题中，我们需要判断 F 和 G 的连通性，并执行必要的合并或删除操作。
    
3. **最小化操作**：通过并查集，可以很容易地判断哪些边需要删除或添加。对于每对顶点 u 和 v，判断它们是否在 `F` 和 `G` 中属于同一连通块（通过 `find` 操作），如果不一致，说明需要添加或删除边。并查集提供了高效的操作来实现这些判断，进而实现最小操作数的目标。

> 我们首先将两个结构存下来 使用`unordered_map<int, unordered_map<int, int>>` 或者`vector<vector<int>>` 都可以，然后对G的所有点做一遍并查集
> 此时我们已经得到了`G`的连通块结构 假设`G`中有 `1 2 3 4` 这么四个集合 接下来让我们尝试对`F` 做并查集 其中每一条边（以及两个顶点`v1` `v2` 可以得到如下两种情况：
> - 对于`v1` `v2` 在G中它们在同一个集合中 那我们需要进行合并
> - 对于`v1` `v2` 在G中它们不在同一个集合中 那我们一定要把这条边拆除 拆除会让操作次数 + 1

> 在检查完之后 我们会得到一定操作次数 `ans` `F` 的集合数量` total1` `G`的集合数量 `total2` 
> 我们刚刚只拆除了G中没有 但是F中有的边 并没有处理G中有 而F中没有的边 
> 这样的边可能导致F的集合数量更多 因为有一些节点没有连起来 比方说F中有 `1 2 3 4 5` 五个集合 其中第五个集合是需要跟前面合并的 但是我们并不关心具体的合并方案 因为不管合并到任何一个集合 操作次数都是1 所以我们要把 `total1` 个集合变成 `total2` 个 合并的次数就应该是 `total1 - total2`
> 进而得到答案 `ans + total1 - total2`

# [2057C](https://codeforces.com/problemset/problem/2057/C)

> 题意：
> 给了 `l` 和 `r`  想要在这之中找出三个数字 `a, b, c` 使得 `f = a ^ b + b ^ c + a ^ c` 最大

> 思路：
> `l`和`r`的范围给得很大 直接枚举是肯定行不通的 我们需要注意到对于任意一个二进制位都有如下几种可能：
> - `0 0 0` 经过 `f` 之后 答案是 `0 ^ 0 + 0 ^ 0 + 0 ^ 0 = 0`
> - `0 0 1` 经过 `f`  之后 答案是 `0 ^ 1 + 0 ^ 1 + 0 ^ 0 = 2`
> - `0 1 1` 经过 `f`  之后 答案是 `0 ^ 1 + 0 ^ 1 + 1 ^ 1 = 2`
> - `1 1 1` 经过 `f`  之后 答案是 `1 ^ 1 + 1 ^ 1 + 1 ^ 1 = 0`
> 因此 我们只需要保证： ==这三个数字的其中两个 在二进制的每一位都不同 就能使答案最大化== 

					  987654321
假设 `r` 的二进制位如下： `101011010`
而     `l` 的二进制位如下： `101001001`
因为`abc` 都要在`l`和`r`中间 所以9 8 7 6这几个`l`和`r`一样的二进制位 他们一定不能做任何调整 否则一定会使得这个数字超出$[l, r]$ 的范围 （可以自己试试！看看`111011001`这个数字是不是特别大）
所以我们只能从第五位开始变动：
让我们尝试一下 把a设置成 `101010000` 前四位保持不变 第五位是比较大的1 剩下的都是0
把b设置成 `101001111` 前四位保持不变 第五位是比较小的0 剩下的都是1

这样的好处就在于 对于后面的五位 我们很好的达到了**其中两个在二进制的每一位都不同** 的效果 而且这是一个非常简单的做法：我们只需要找到`r`和`l`第一个不一样的数字 就能非常简单的构造出符合要求的`a`和`b` （设想 如果把a设置成`101011111` `b`设置成`101000000` 是不是还得关心他们是否超出$[l, r]$ 的范围

> 所以接下来思路很明显了：找到`l`和`r`第一个不相同的位 在这个位之前 我们要跟`l, r` 完全一样 在这个位之后 我们都设置成0 如此可以得到a `101010000`
> 接下来 a - 1 就可以得到 b `101001111` 
> 至于第三个数字 根据刚刚标黄的结论 可以推断**不管它是什么数字 都已经可以让异或和最大化了** 

第一个难点 如何求出首个不一样的位置
这里介绍两种思路：
```cpp
// pos1
int k = 31 - __builtin_clz(l ^ y);
```

> [!node] 
> ### **内建函数（Built-in Functions）**
> 这些函数是由 GCC 提供的，可以直接在代码中使用，不需要显式声明。 
> - `__builtin_popcount(x)`：计算 `x` 的二进制表示中 `1` 的个数。
> - `__builtin_ctz(x)`：计算 `x` 中最低有效位（从右往左）的零的个数。
> - `__builtin_clz(x)`：计算 `x` 中最高有效位（从左往右）的零的个数。
> - `__builtin_ffs(x)`：返回 `x` 中最低有效位（从右往左）的第一个 `1` 位的位置。
> - `__builtin_parity(x)`：返回 `x` 的奇偶校验位（如果 `x` 的二进制表示中 `1` 的个数是奇数，则返回 1；否则返回 0）。

也就是说 我们可以通过`__builtin_clz` 来快速求得从左到右0的数量 用31减一下就得到1的位置了
> [?]
> 为什么用31减？
> 因为int 是三十二位整数 **最左边的那一位用来存放符号** 所以能用的其实只有三十一位

```cpp
// pos2
int k = 0;
int x = l ^ r;
while (x)
{
	k++;
	x >>= 1; // 左移
}
k--; // 
```
>   **为什么要 `k--`？**
> - 在上面的例子中，`x = 2`（`0010`）经过两次右移后，`k` 最终增加到 2。事实上，`k = 2` 表示的是 **`x` 中有 2 个 `1`**，而我们只关心的是第一个不同的 `1`，即在第 1 位的位置（从 0 开始计数）。
> - 由于循环每次右移 `x` 后，`k` 都增加 1，因此 `k` 的值实际上是 **最后一个 `1` 位置的下一个位置**。因此，在循环结束后，我们需要 `k--` 来回到我们需要的位置，即第一个不同的位。

现在 我们成功获得了k (表示第k个数字是不同的)
下一步 需要构造出a 使得 k位是1 之前和`l， r` 一样 之后都是0 这是十分困难的
我们换一种角度想 可以构造b = a - 1  使得 k位是0 之前和`l， r` 一样 之后都是1
如何做到呢？ 我们可以利用或运算
> [!Node]
> `&` 与运算 保留所有进位
> `|`或运算 保留所有1
> `^` 异或运算 二进制不进位加法
> 看不懂的话建议自行查询资料 反复看懂 这个非常重要

我们先构造数字`m = (1 << k) - 1` 然后有`b = l | m` 这样就完美达到了效果：
第`k`位 ， `m` 和 `l` 都是`0` 
`k`之上 ，都跟`l`一样
`k`之下 ，保留了所有的`1` **而`m`全部都是`1`**

自此 我们得到了最终的结果
```cpp
int k = 31 - __builtin_clz(l ^ y);
int b = l | (1 << k) - 1, a = b + 1, c = (b == l ? r : l); 
// c是任何一个数字都可以 可以参考一下这个构造思路 不是l就是r
cout << a << ' ' << b << ' ' << c;
```

# [2055C](https://codeforces.com/problemset/problem/2055/C)

> 题意：
> 给一个矩阵和一个运动轨迹 运动轨迹经过的地方数字都变成了0 现在已知他们原来每行的数字和相等 每列的数字和相等 请把所有的0填写出来 答案不唯一

> 思路：
> 看起来是一个数独题， 其实我们只需要让**每行每列的格子数字和都是0** 就可以了
> 这是观察示例得出来的结论，有时候确实需要一些注意力

思路很直接 但是实现过程值得细品 我在这里贴出我的代码，作为参考：
```cpp
void solve()
{
    int n, m;
    cin >> n >> m;
    string s;
    cin >> s;
    vector v(n, vector<int>(m));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> v[i][j];
    int x = 0, y = 0;
    for (auto &&c : s)
    {
        if (c == 'D') // 往下走 计算一行的和 x确定 计算y
        {
            int temp = 0;
            for (int i = 0; i < m; i++)
            {
                temp += v[x][i];
            }
            v[x++][y] = -temp;
        }
        else // 往右走 计算每一列的和 y确定 计算x
        {
            int temp = 0;
            for (int i = 0; i < n; i++)
            {
                temp += v[i][y];
            }
            v[x][y++] = -temp;
        }
    }
	// 最后需要对终点进行额外处理
    int temp = 0;
    for (int i = 0; i < m; i++)
    {
        temp += v[n - 1][i];
    }
    v[n - 1][m - 1] = -temp;
    
	// 输出结果
	...
}
```
题解给出来说这是双指针 算吗？一个x一个y确实也算吧

# [2050E](https://codeforces.com/problemset/problem/2050/E)

> 题意：
> 给a, b, c三个字符串 要求任选a b中的字母按照顺序尽可能摆成c的样子 问最少需要改变多少个字符才能使得他们相等

> 思路：
> 是一道dp题目 设 `dp[i][j]` 是用了`a`中前`i`个字符 `b`中前`j`个字符 得到`c`中前 `i + j` 个字符 改变的最小值
> 想不到吧？想不到就积累起来
> 初始化：求的是最小值 那么创建的时候就全部设置成`INT_MAX` 
> 			`dp[0][0] = 0` 表示什么字母都不选 当然不需要改变
> 		`dp[i][0]` 肯定都只跟a有关系 同理，`dp[0][i]` 肯定只跟b有关 
> 状态转移：给一个字符串 可以通过选择a中字符 或者选择b中字符来继续摆 我们需要对二者求min

```cpp
void solve()
{
    string a, b, c;
    cin >> a >> b >> c;
    int n = a.size(), m = b.size();
    vector dp(n + 1, vector<int>(m + 1, INF));
    dp[0][0] = 0;
    for (int i = 1; i <= n; i++)
    {
        dp[i][0] = dp[i - 1][0] + (a[i - 1] != c[i - 1]);
    }
    for (int j = 1; j <= m; j++)
    {
        dp[0][j] = dp[0][j - 1] + (b[j - 1] != c[j - 1]);
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
			dp[i][j] = min(
							dp[i - 1][j] + (a[i - 1] != c[i + j - 1]),
							dp[i][j - 1] + (b[j - 1] != c[i + j - 1])
							);
        }
    }
    cout << dp[n][m];
}
```

> 感觉还是很难想的 需要多多积累

# [2049C](https://codeforces.com/problemset/problem/2049/C)

> 题意：
> 一个环多一条边 让求mex

> 思路：
> 我们需要很好的注意到环的性质 下次遇到成环的问题可以试着朝 平面图形的顶点数量 来讨论
> 一个环多一条边 可能会有几种情况呢？
> - 本来是奇数个点的环 加了一条边变成一奇一偶
> - 本来是偶数个点的环 加了一条边变成两偶
> - 本来是偶数个点的环 加了一条边变成两奇
> 因此我们可以如下讨论：
> - 成环的顶点数量都是偶数的时候 我们只需要`0 1 0 1 ...` 这样排布就行
> - 成环的顶点数量出现奇数的时候  我们需要让其中一个顶点变成2 剩下的`0 1` 排布


# [2045C](https://codeforces.com/problemset/problem/2045/C)

> 题意：
> 给两个字符串a, b 需要找到一个最短的答案 使得他可以由 `o p q`三段组成 其中 `o` 是a的前缀 `p` 是公共部分 `q` 是b的后缀

> 思路：
> 我们想要找到最短的 答案 那么只需要遍历所有的公共部分 找出最小值
> 第一步 我们遍历一遍a串 用一个map记录a中每一个元素第一次出现的位置
> 第二步 我们**从后往前**遍历一遍b串 对b的每一个元素 我们查找map中有没有这个元素 如果有的话（已经被记录位置），我们就`check mp[x] + j`  是否 `< ans` 
> `if true` 我们更新`s = a.substr(0, mp[x] + 1) + b.substr(b.size() - j)` 
> 最后输出s 即可

代码：
```cpp
void solve()
{
    string a, b;
    cin >> a >> b;
    map<char, int> mp;                 // 记录a中字符第一个出现的位置
    for (int i = 1; i < a.size(); i++) // a一定要出现一个字符 因为需要前缀
    {
        if (mp.count(a[i]) == 0)
        {
            mp[a[i]] = i;
        }
    }
    int ans = INT_MAX;
    string s = "";
    for (int j = 1; j < b.size(); j++)
    {
        char x = b[b.size() - j - 1];
        if (mp.count(x) and j + mp[x] < ans)
        {
            s = a.substr(0, mp[x] + 1) + b.substr(b.size() - j);
            ans = mp[x] + j;
        }
    }
    cout << (s.size() == 0 ? "-1" : s);
}
```
# [2038C](https://codeforces.com/problemset/problem/2038/C)

> 题意：
> 给一堆数字 要求构造一个平行于坐标轴的 面积最大的矩形 构造不了就输出 `NO`

> 思路:
> 对给出的数字 我们存到map里面 遍历一遍map 每当出现两个相同的数字 我们令check++ 最后检查check是否到达了4 如果没有的话说明根本不可能构造出跟坐标轴平行的四条边 直接输出`NO` 
> 在此基础上 我们对可以取出来的数字排序一遍 把最小的两个和最大的两个排列组合一遍 看看如何构造能获得最大面积 输出答案即可

代码：
```cpp
int n, num;
cin >> n;
map<int, int> mp;
while (n--)
{
	cin >> num;
	mp[num]++;
}
vevctor<int> v;
for (auto &&[k, val] : mp)
{
	for (int i = 0; i < val / 2; i++)
	{
		v.emplace_back(k);
	}
}

if (v.size() < 4) 
{
	cout << "NO";
	return;
}

ranges::sort(v);
int x1 = v[0], y1 = v[1], x2 = v[v.size() - 1], y2 = v[v.size() - 2];

if ((x2 - x1) * (y2 - y1) > (y2 - x1) * (x2 - y1))
{
	swap(x2, y2);
}
cout << x1 << ' ' << x2 << ' ' << x1 << ' ' << y1 << ' ' << x2 << ' ' << y1 << ' ' << x2 << ' ' << y2;
```

# [2038A](https://codeforces.com/problemset/problem/2038/A)

> 题意：
> 题目出的不好 我的个人理解是对于每一个ai, bi 最前面的人会尽可能偷懒 也就是说最后面的人要尽可能多工作 
> 

> 思路:
> 根据  $s_i = a_i − c * b_i$ 当收益最小的时候有 $\frac{a_i}{b_i} >= c$ 也就是最后面的人需要尽可能工作$c_i = min(k, \frac{a_i}{b_i})$  我们尝试比较  $k \ \ and \ \ \sum_{i = 1}^{n} c_i$ 的大小 如果k大 那就说明根本无法达到工作量 全部输出0即可

代码：
```cpp
int n, k;
cin >> n >> k;
vector<int> a(n + 1), b(n + 1);
for (int i = 1; i <= n; i++) cin >> a[i];
for (int i = 1; i <= n; i++) cin >> b[i];

vector<int> c(n + 1, 0);
int tot = 0;
for (int i = n; i >= 1; i--)
{
	c[i] = min(k, a[i] / b[i]);
	tot += c[i];
	k -= c[i];
}
for (int i = 1; i <= n; i++) cout << (k ? 0 : c[i]) << ' ';
```

> 个人感觉不是一道好题 题面描述的模糊不清

# [[DAY 2]] 